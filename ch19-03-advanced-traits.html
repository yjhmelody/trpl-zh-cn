<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>高级 trait - 高级 trait - Rust 程序设计语言 简体中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust 程序设计语言 简体中文版">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }

            a .hljs {
                color: #4183c4;
            }

            .rust .content a .hljs,
            .coal .content a .hljs,
            .navy .content a .hljs {
                color: #2b79a2;
            }

            a:hover .hljs {
                text-decoration: underline;
            }

            /* Styles keystrokes such as ctrl-C */
            .keystroke {
                font-variant: small-caps;
            }
        </style>

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> 介绍</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> 安装</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> 猜猜看教程</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> 通用编程概念</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> 变量与可变性</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> 数据类型</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> 函数如何工作</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> 注释</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> 控制流</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> 认识所有权</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> 什么是所有权</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> 引用与借用</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> Slices</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> 使用结构体来组织相关联的数据</a></li><li><ul class="section"><li><a href="ch05-01-defining-structs.html"><strong>5.1.</strong> 定义并实例化结构体</a></li><li><a href="ch05-02-example-structs.html"><strong>5.2.</strong> 一个使用结构体的示例程序</a></li><li><a href="ch05-03-method-syntax.html"><strong>5.3.</strong> 方法语法</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> 枚举与模式匹配</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> 定义枚举</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> <code>match</code> 控制流运算符</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> <code>if let</code> 简洁控制流</a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> 模块</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code> 与文件系统</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> 使用 <code>pub</code> 控制可见性</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> 在不同的模块中引用命名</a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> 通用集合类型</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> vector</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> 字符串</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> 哈希 map</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> 错误处理</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> <code>panic!</code> 与不可恢复的错误</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> <code>Result</code> 与可恢复的错误</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> <code>panic!</code> 还是不 <code>panic!</code></a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> 泛型、trait 与生命周期</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> 泛型数据类型</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> trait：定义共享的行为</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> 生命周期与引用有效性</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> 测试</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> 编写测试</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> 运行测试</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> 测试的组织结构</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> 一个 I/O 项目：构建命令行程序</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> 接受命令行参数</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> 读取文件</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> 重构以改进模块化与错误处理</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> 采用测试驱动开发完善库的功能</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> 处理环境变量</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> 将错误信息输出到标准错误而不是标准输出</a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Rust 中的函数式语言功能：迭代器与闭包</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> 闭包：可以捕获其环境的匿名函数</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> 使用迭代器处理元素序列</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> 改进之前的 I/O 项目</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> 性能比较：循环对迭代器</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> 更多关于 Cargo 和 Crates.io 的内容</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> 采用发布配置自定义构建</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> 将 crate 发布到 Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo 工作空间</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> 使用 <code>cargo install</code> 从 Crates.io 安装二进制文件</a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Cargo 自定义扩展命令</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> 智能指针</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> 在堆上存储数据，并且可确定大小</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> <code>Deref</code> Trait 允许通过引用访问数据</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> <code>Drop</code> Trait 运行清理代码</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code> 引用计数智能指针</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> 和内部可变性模式</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> 引用循环和内存泄漏是安全的</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> 无畏并发</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> 线程</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> 消息传递</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> 共享状态</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> 可扩展的并发：<code>Sync</code>和<code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Rust 是面向对象语言吗？</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> 什么是面向对象？</a></li><li><a href="ch17-02-trait-objects.html"><strong>17.2.</strong> 为使用不同类型的值而设计的 trait 对象</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong>17.3.</strong> 面向对象设计模式的实现</a></li></ul></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> 模式用来匹配值的结构</a></li><li><ul class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong>18.1.</strong> 所有可能会用到模式的位置</a></li><li><a href="ch18-02-refutability.html"><strong>18.2.</strong> Refutability：何时模式可能会匹配失败</a></li><li><a href="ch18-03-pattern-syntax.html"><strong>18.3.</strong> 模式的全部语法</a></li></ul></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> 高级特征</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> 不安全的 Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong>19.2.</strong> 高级生命周期</a></li><li><a href="ch19-03-advanced-traits.html" class="active"><strong>19.3.</strong> 高级 trait</a></li><li><a href="ch19-04-advanced-types.html"><strong>19.4.</strong> 高级类型</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong>19.5.</strong> 高级函数与闭包</a></li></ul></li><li><a href="ch20-00-final-project-a-web-server.html"><strong>20.</strong> 最后的项目: 构建多线程 web server</a></li><li><ul class="section"><li><a href="ch20-01-single-threaded.html"><strong>20.1.</strong> 单线程 web server</a></li><li><a href="ch20-02-slow-requests.html"><strong>20.2.</strong> 慢请求如何影响吞吐率</a></li><li><a href="ch20-03-designing-the-interface.html"><strong>20.3.</strong> 设计线程池接口</a></li><li><a href="ch20-04-storing-threads.html"><strong>20.4.</strong> 创建线程池并储存线程</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong>20.5.</strong> 使用通道向线程发送请求</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong>20.6.</strong> Graceful Shutdown 与清理</a></li></ul></li><li><a href="appendix-00.html"><strong>21.</strong> 附录</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - 关键字</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - 运算符与符号</a></li><li><a href="appendix-03-derivable-traits.html"><strong>21.3.</strong> C - 可导出的 trait</a></li><li><a href="appendix-04-macros.html"><strong>21.4.</strong> D - 宏</a></li><li><a href="appendix-05-translation.html"><strong>21.5.</strong> E - 本书翻译</a></li><li><a href="appendix-06-newest-features.html"><strong>21.6.</strong> F - 最新功能</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page" tabindex="-1">
                
                <header></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程序设计语言 简体中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="ch19-03-advanced-traits.html#高级-trait" id="高级-trait"><h2>高级 trait</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch19-03-advanced-traits.md">ch19-03-advanced-traits.md</a>
<br>
commit f8727711388b28eb2f5c852dd83fdbe6d22ab9bb</p>
</blockquote>
<p>第十章讲到了 trait，不过就像生命周期，我们并没有涉及所有的细节。现在我们更加了解 Rust 了，可以深入理解本质了。</p>
<a class="header" href="ch19-03-advanced-traits.html#关联类型" id="关联类型"><h3>关联类型</h3></a>
<p><strong>关联类型</strong>（<em>associated types</em>）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。实现一个 trait 的人只需要针对专门的实现在这个类型的位置指定相应的类型即可。</p>
<p>本章描述的大部分内容都非常少见。关联类型则比较适中；它们比本书其他的内容要少见，不过比本章中的很多内容要更常见。</p>
<p>一个带有关联类型的 trait 的例子是标准库提供的 <code>Iterator</code> trait。它有一个叫做 <code>Item</code> 的关联类型来替代遍历的值的类型。第十三章曾提到过 <code>Iterator</code> trait 的定义如列表 19-20 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
#}</code></pre></pre>
<p><span class="caption">列表 19-20：<code>Iterator</code> trait 的定义中带有关联类型 <code>Item</code></span></p>
<p>这就是说 <code>Iterator</code> trait 有一个关联类型 <code>Item</code>。<code>Item</code> 是一个占位类型，同时 <code>next</code> 方法会返回 <code>Option&lt;Self::Item&gt;</code> 类型的值。这个 trait 的实现者会指定 <code>Item</code> 的具体类型，然而不管实现者指定何种类型, <code>next</code> 方法都会返回一个包含了这种类型值的 <code>Option</code>。</p>
<a class="header" href="ch19-03-advanced-traits.html#关联类型-vs-泛型" id="关联类型-vs-泛型"><h4>关联类型 vs 泛型</h4></a>
<p>当在列表 13-6 中在 <code>Counter</code> 结构体上实现 <code>Iterator</code> trait 时，将 <code>Item</code> 的类型指定为 <code>u32</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#}</code></pre></pre>
<p>这感觉类似于泛型。那么为什么 <code>Iterator</code> trait 不像列表 19-21 那样定义呢？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
#}</code></pre></pre>
<p><span class="caption">列表 19-21：一个使用泛型的 <code>Iterator</code> trait 假象定义</span></p>
<p>区别是在列表 19-21 的定义中，我们也可以实现 <code>Iterator&lt;String&gt; for Counter</code>，或者任何其他类型，这样就可以有多个 <code>Counter</code> 的 <code>Iterator</code> 的实现。换句话说，当 trait 有泛型参数时，可以多次实现这个 trait，每次需改变泛型参数的具体类型。接着当使用 <code>Counter</code> 的 <code>next</code> 方法时，必须提供类型注解来表明希望使用 <code>Iterator</code> 的哪一个实现。</p>
<p>通过关联类型，不能多次实现 trait。使用列表 19-20 中这个 <code>Iterator</code> 的具体定义，只能选择一次 <code>Item</code> 会是什么类型，因为只能有一个 <code>impl Iterator for Counter</code>。当调用 <code>Counter</code> 的 <code>next</code> 时不必每次指定我们需要 <code>u32</code> 值的迭代器。</p>
<p>当 trait 使用关联类型时不必指定泛型参数的好处也在另外一些方面得到体现。考虑一下列表 19-22 中定义的两个 trait。他们都必须处理一个包含一些节点和边的图结构。<code>GGraph</code> 定义为使用泛型，而 <code>AGraph</code> 定义为使用关联类型：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait GGraph&lt;Node, Edge&gt; {
    // methods would go here
}

trait AGraph {
    type Node;
    type Edge;

    // methods would go here
}
#}</code></pre></pre>
<p><span class="caption">列表 19-22：两个图 trait 定义，<code>GGraph</code> 使用泛型而 <code>AGraph</code> 使用关联类型代表 <code>Node</code> 和 <code>Edge</code></span></p>
<p>比如说想要是实现一个计算任何实现了图 trait 的类型中两个节点之间距离的函数。对于使用泛型的 <code>GGraph</code> trait 来说，<code>distance</code> 函数的签名看起来应该如列表 19-23 所示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait GGraph&lt;Node, Edge&gt; {}
#
fn distance&lt;N, E, G: GGraph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 {
#     0
}
#}</code></pre></pre>
<p><span class="caption">列表 19-23：<code>distance</code> 函数的签名，它使用 <code>GGraph</code> trait 并必须指定所有的泛型参数</span></p>
<p>函数需要指定泛型参数 <code>N</code>、<code>E</code> 和 <code>G</code>，其中 <code>G</code> 拥有以 <code>N</code> 类型作为 <code>Node</code> 和 <code>E</code> 类型作为 <code>Edge</code> 的 <code>GGraph</code> trait 作为 trait bound。即便 <code>distance</code> 函数无需指定边的类型，我们也强制声明了 <code>E</code> 参数，因为需要使用 <code>GGraph</code> trait, 而 <code>GGraph</code> 需要指定 <code>Edge</code> 的类型。</p>
<p>与此相对，列表 19-24 中的 <code>distance</code> 定义使用列表 19-22 中带有关联类型的 <code>AGraph</code> trait：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait AGraph {
#     type Node;
#     type Edge;
# }
#
fn distance&lt;G: AGraph&gt;(graph: &amp;G, start: &amp;G::Node, end: &amp;G::Node) -&gt; u32 {
#     0
}
#}</code></pre></pre>
<p><span class="caption">列表 19-24：<code>distance</code> 函数的签名，它使用 trait <code>AGraph</code> 和关联类型 <code>Node</code></span></p>
<p>这样就清楚多了。只需指定一个泛型参数 <code>G</code>，带有 <code>AGraph</code> trait bound。因为 <code>distance</code> 完全不需要使用 <code>Edge</code> 类型，无需每次都指定它。为了使用 <code>AGraph</code> 的关联类型 <code>Node</code>，可以指定为 <code>G::Node</code>。</p>
<a class="header" href="ch19-03-advanced-traits.html#带有关联类型的-trait-对象" id="带有关联类型的-trait-对象"><h4>带有关联类型的 trait 对象</h4></a>
<p>你可能会好奇为什么不在列表 19-23 和 19-24 的 <code>distance</code> 函数中使用 trait 对象。当使用 trait 对象时使用泛型 <code>GGraph</code> trait 的 <code>distance</code> 函数的签名确实更准确了一些：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait GGraph&lt;Node, Edge&gt; {}
#
fn distance&lt;N, E&gt;(graph: &amp;GGraph&lt;N, E&gt;, start: &amp;N, end: &amp;N) -&gt; u32 {
#     0
}
#}</code></pre></pre>
<p>与列表 19-24 相比较可能更显公平。不过依然需要指定 <code>Edge</code> 类型，这意味着列表 19-24 仍更为合适，因为无需指定并不需要的类型。</p>
<p>不可能改变列表 19-24 来对图使用 trait 对象，因为这样就无法引用 <code>AGraph</code> trait 中的关联类型。</p>
<p>但是一般而言常见的情形是使用带有关联类型 trait 的 trait 对象；列表 19-25 展示了一个函数 <code>traverse</code> ，它无需在其他参数中使用关联类型。然而这种情况必须指定关联类型的具体类型。这里选择接受以 <code>usize</code> 作为 <code>Node</code> 和以两个 <code>usize</code> 值的元组作为  <code>Edge</code> 的实现了 <code>AGraph</code> trait 的类型：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait AGraph {
#     type Node;
#     type Edge;
# }
#
fn traverse(graph: &amp;AGraph&lt;Node=usize, Edge=(usize, usize)&gt;) {}
#}</code></pre></pre>
<p>虽然 trait 对象意味着无需在编译时就知道 <code>graph</code> 参数的具体类型，但是我们确实需要在 <code>traverse</code> 函数中通过具体的关联类型来限制 <code>AGraph</code> trait 的使用。如果不提供这样的限制，Rust 将不能计算出用哪个 <code>impl</code> 来匹配这个 trait 对象，因为关联类型可以作为方法签名的一部分，Rust 需要在虚函数表(vtable)中查找它们。</p>
<a class="header" href="ch19-03-advanced-traits.html#运算符重载和默认类型参数" id="运算符重载和默认类型参数"><h3>运算符重载和默认类型参数</h3></a>
<p><code>&lt;PlaceholderType=ConcreteType&gt;</code> 语法也可以以另一种方式使用：用来指定泛型的默认类型。这种情况的一个非常好的例子是用于运算符重载。</p>
<p>Rust 并不允许创建自定义运算符或重载任意运算符，不过 <code>std::ops</code> 中所列出的运算符和相应的 trait 可以通过实现运算符相关 trait 来重载。例如，列表 19-25 中展示了如何在 <code>Point</code> 结构体上实现 <code>Add</code> trait 来重载 <code>+</code> 运算符，这样就可以将两个 <code>Point</code> 实例相加了：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug,PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<p><span class="caption">列表 19-25：实现 <code>Add</code> 来重载 <code>Point</code> 的 <code>+</code> 运算符</span></p>
<p>这里实现了 <code>add</code> 方法将两个 <code>Point</code> 实例的 <code>x</code> 值和 <code>y</code> 值分别相加来创建一个新的 <code>Point</code>。<code>Add</code> trait 有一个叫做 <code>Output</code> 的关联类型，它用来决定 <code>add</code> 方法的返回值类型。</p>
<p>让我们更仔细的看看 <code>Add</code> trait。这里是其定义：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
#}</code></pre></pre>
<p>这看来应该很熟悉；这是一个带有一个方法和一个关联类型的 trait。比较陌生的部分是尖括号中的 <code>RHS=Self</code>：这个语法叫做<strong>默认类型参数</strong>（<em>default type parameters</em>）。<code>RHS</code> 是一个泛型参数（“right hand side” 的缩写），它用于 <code>add</code> 方法中的 <code>rhs</code> 参数。如果实现 <code>Add</code> trait 时不指定 <code>RHS</code> 的具体类型，<code>RHS</code> 的类型将是默认的 <code>Self</code> 类型（在其上实现 <code>Add</code> 的类型）。</p>
<p>让我们看看另一个实现了 <code>Add</code> trait 的例子。想象一下我们拥有两个存放不同的单元值的结构体，<code>Millimeters</code> 和 <code>Meters</code>。可以如列表 19-26 所示那样用不同的方式为 <code>Millimeters</code> 实现 <code>Add</code> trait：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Millimeters) -&gt; Millimeters {
        Millimeters(self.0 + other.0)
    }
}

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
#}</code></pre></pre>
<p><span class="caption">列表 19-26：在 <code>Millimeters</code> 上实现 <code>Add</code>，以能够将<code>Millimeters</code> 与 <code>Millimeters</code> 相加和将 <code>Millimeters</code> 与 <code>Meters</code> 相加</span></p>
<p>如果将 <code>Millimeters</code> 与其他 <code>Millimeters</code> 相加，则无需为 <code>Add</code> 参数化 <code>RHS</code> 类型，因为默认的 <code>Self</code> 正是我们希望的。如果希望实现 <code>Millimeters</code> 与 <code>Meters</code> 相加，那么需要声明为 <code>impl Add&lt;Meters&gt;</code> 来设定 <code>RHS</code> 类型参数的值。</p>
<p>默认参数类型主要用于如下两个方面：</p>
<ol>
<li>扩展类型而不破坏现有代码。</li>
<li>允许以一种大部分用户都不需要的方法进行自定义。</li>
</ol>
<p><code>Add</code> trait 就是第二个目的一个例子：大部分时候你会将两个相似的类型相加。在 <code>Add</code> trait 定义中使用默认类型参数使得实现 trait 变得更容易，因为大部分时候无需指定这额外的参数。换句话说，这样就去掉了一些实现的样板代码。</p>
<p>第一个目的是相似的，但过程是反过来的：因为现有 trait 实现并没有指定类型参数，如果需要为现有 trait 增加类型参数，为其提供一个默认值将允许我们在不破坏现有实现代码的基础上扩展 trait 的功能。</p>
<a class="header" href="ch19-03-advanced-traits.html#完全限定语法与消歧义" id="完全限定语法与消歧义"><h3>完全限定语法与消歧义</h3></a>
<p>Rust 既不能避免一个 trait 与另一个 trait 拥有相同名称的方法，也不能阻止为同一类型同时实现这两个 trait。甚至也可以直接在类型上实现相同名称的方法！那么为了能使用相同的名称调用每一个方法，需要告诉 Rust 我们希望使用哪个方法。考虑一下列表 19-27 中的代码，trait <code>Foo</code> 和 <code>Bar</code> 都拥有方法 <code>f</code>，并在结构体 <code>Baz</code> 上实现了这两个 trait，结构体也有一个叫做 <code>f</code> 的方法：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Foo {
    fn f(&amp;self);
}

trait Bar {
    fn f(&amp;self);
}

struct Baz;

impl Foo for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
}

impl Bar for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
}

impl Baz {
    fn f(&amp;self) { println!(&quot;Baz's impl&quot;); }
}

fn main() {
    let b = Baz;
    b.f();
}
</code></pre></pre>
<p><span class="caption">列表 19-27：实现两个拥有相同名称的方法的 trait，同时还有直接定义于结构体的（同名）方法</span></p>
<p>对于 <code>Baz</code> 的 <code>Foo</code> trait 中方法 <code>f</code> 的实现，它打印出 <code>Baz's impl of Foo</code>。对于 <code>Baz</code> 的 <code>Bar</code> trait 中方法 <code>f</code> 的实现，它打印出 <code>Baz's impl of Bar</code>。直接定义于 <code>Baz</code> 的 <code>f</code> 实现打印出 <code>Baz's impl</code>。当调用 <code>b.f()</code> 时会发生什么呢？在这个例子中，Rust 总是会使用直接定义于 <code>Baz</code> 的实现并打印出 <code>Baz's impl</code>。</p>
<p>为了能够调用 <code>Foo</code> 和 <code>Baz</code> 中的 <code>f</code> 方法而不是直接定义于 <code>Baz</code> 的 <code>f</code> 实现，则需要使用<strong>完全限定语法</strong>（<em>fully qualified syntax</em>）来调用方法。它像这样工作：对于任何类似如下的方法调用：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
receiver.method(args);
#}</code></pre></pre>
<p>可以像这样使用完全限定的方法调用：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
&lt;Type as Trait&gt;::method(receiver, args);
#}</code></pre></pre>
<p>所以为了消歧义并能够调用列表 19-27 中所有的 <code>f</code> 方法，需要在尖括号中指定每个希望 <code>Baz</code> 作为的 trait，接着使用双冒号，接着传递 <code>Baz</code> 实例作为第一个参数并调用 <code>f</code> 方法。列表 19-28 展示了如何调用 <code>Foo</code> 中的 <code>f</code>，和 <code>Bar</code> 中与 <code>b</code> 中的 <code>f</code>：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Foo {
#     fn f(&amp;self);
# }
# trait Bar {
#     fn f(&amp;self);
# }
# struct Baz;
# impl Foo for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
# }
# impl Bar for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
# }
# impl Baz {
#     fn f(&amp;self) { println!(&quot;Baz's impl&quot;); }
# }
#
fn main() {
    let b = Baz;
    b.f();
    &lt;Baz as Foo&gt;::f(&amp;b);
    &lt;Baz as Bar&gt;::f(&amp;b);
}
</code></pre></pre>
<p><span class="caption">列表 19-28：使用完全限定语法调用作为<code>Foo</code> 和 <code>Bar</code> trait 一部分的 <code>f</code> 方法</span></p>
<p>这会打印出：</p>
<pre><code>Baz's impl
Baz’s impl of Foo
Baz’s impl of Bar
</code></pre>
<p>只在存在歧义时才需要 <code>Type as</code> 部分，只有需要 <code>Type as</code> 时才需要 <code>&lt;&gt;</code> 部分。所以如果在作用域中只有定义于 <code>Baz</code> 和 <code>Baz</code> 上实现的 <code>Foo</code> trait 的 <code>f</code> 方法的话，则可以使用 <code>Foo::f(&amp;b)</code> 调用 <code>Foo</code> 中的 <code>f</code> 方法，因为无需与 <code>Bar</code> trait 相区别。</p>
<p>也可以使用 <code>Baz::f(&amp;b)</code> 调用直接定义于 <code>Baz</code> 上的 <code>f</code> 方法，不过因为这个定义是在调用 <code>b.f()</code> 时默认使用的，并不要求调用此方法时使用完全限定的名称。</p>
<a class="header" href="ch19-03-advanced-traits.html#父-trait-用于在另一个-trait-中使用某-trait-的功能" id="父-trait-用于在另一个-trait-中使用某-trait-的功能"><h3>父 trait 用于在另一个 trait 中使用某 trait 的功能</h3></a>
<p>有时我们希望当实现某 trait 时依赖另一个 trait 也被实现，如此这个 trait 就可以使用其他 trait 的功能。这个所需的 trait 是我们实现的 trait 的<strong>父（超） trait</strong>（<em>supertrait</em>）。</p>
<p>例如，加入我们希望创建一个带有 <code>outline_print</code> 方法的 trait <code>OutlinePrint</code>，它会打印出带有星号框的值。也就是说，如果 <code>Point</code> 实现了 <code>Display</code> 并返回 <code>(x, y)</code>，调用以 1 作为 <code>x</code> 和 3 作为 <code>y</code> 的 <code>Point</code> 实例的 <code>outline_print</code> 会显示如下：</p>
<pre><code>**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>在 <code>outline_print</code> 的实现中，因为希望能够使用 <code>Display</code> trait 的功能，则需要说明 <code>OutlinePrint</code> 只能用于同时也实现了 <code>Display</code> 并提供了 <code>OutlinePrint</code> 需要的功能的类型。可以在 trait 定义中指定 <code>OutlinePrint: Display</code> 来做到这一点。这类似于为 trait 增加 trait bound。列表 19-29 展示了一个 <code>OutlinePrint</code> trait 的实现：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
#}</code></pre></pre>
<p><span class="caption">列表 19-29：实现 <code>OutlinePrint</code> trait，它要求来自 <code>Display</code> 的功能</span></p>
<p>因为指定了 <code>OutlinePrint</code> 需要 <code>Display</code> trait，则可以在 <code>outline_print</code> 中使用 <code>to_string</code>（<code>to_string</code> 会为任何实现 <code>Display</code> 的类型自动实现）。如果不在 trait 名后增加 <code>: Display</code> 并尝试在 <code>outline_print</code> 中使用 <code>to_string</code>，则会得到一个错误说在当前作用域中没有找到用于 <code>&amp;Self</code> 类型的方法 <code>to_string</code>。</p>
<p>如果尝试在一个没有实现 <code>Display</code> 的类型上实现 <code>OutlinePrint</code>，比如 <code>Point</code> 结构体：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait OutlinePrint {}
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
#}</code></pre></pre>
<p>则会得到一个错误说 <code>Display</code> 没有被实现而 <code>Display</code> 被 <code>OutlinePrint</code> 所需要：</p>
<pre><code>error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for
   `Point`
   |
   = note: `Point` cannot be formatted with the default formatter; try using
   `:?` instead if you are using a format string
   = note: required by `OutlinePrint`
</code></pre>
<p>一旦在 <code>Point</code> 上实现 <code>Display</code> 并满足 <code>OutlinePrint</code> 要求的限制，比如这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
#}</code></pre></pre>
<p>那么在 <code>Point</code> 实现 <code>OutlinePrint</code> trait 将能成功编译并可以在 <code>Point</code> 实例上调用 <code>outline_print</code> 来显示位于星号框中的点的值。</p>
<a class="header" href="ch19-03-advanced-traits.html#newtype-模式用以在外部类型上实现外部-trait" id="newtype-模式用以在外部类型上实现外部-trait"><h3>newtype 模式用以在外部类型上实现外部 trait</h3></a>
<p>在第十章中，我们提到了孤儿规则（orphan rule），它说明只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait。一个绕开这个限制的方法是使用<strong>newtype 模式</strong>（<em>newtype pattern</em>），它涉及到使用一个元组结构体来创建一个新类型，它带有一个字段作为希望实现 trait 的类型的简单封装。接着这个封装类型对于 crate 是本地的，这样就可以在这个封装上实现 trait。“Newtype” 是一个源自 Haskell 编程语言的概念。使用这个模式没有运行时性能惩罚。这个封装类型在编译时被省略了。</p>
<p>例如，如果想要在 <code>Vec</code> 上实现 <code>Display</code>，可以创建一个包含 <code>Vec</code> 实例的 <code>Wrapper</code> 结构体。接着可以如列表 19-30 那样在 <code>Wrapper</code> 上实现 <code>Display</code> 并使用 <code>Vec</code> 的值：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">列表 19-30：创建 <code>Wrapper</code> 类型封装 <code>Vec&lt;String&gt;</code> 以便实现 <code>Display</code></span></p>
<p><code>Display</code> 的实现使用 <code>self.0</code> 来访问其内部的 <code>Vec</code>，接着就可以使用 <code>Wrapper</code> 中 <code>Display</code> 的功能了。</p>
<p>此方法的缺点是因为 <code>Wrapper</code> 是一个新类型，它没有定义于其值之上的方法；必须直接在 <code>Wrapper</code> 上实现 <code>Vec</code> 的所有方法，如 <code>push</code>、<code>pop</code> 等等，并代理到 <code>self.0</code> 上以便可以将 <code>Wrapper</code> 完全当作 <code>Vec</code> 处理。如果希望新类型拥有其内部类型的每一个方法，为封装类型实现第十五章讲到的 <code>Deref</code> trait 并返回其内部类型是一种解决方案。如果不希望封装类型拥有所有内部类型的方法，比如为了限制封装类型的行为，则必须自行实现所需的方法。</p>
<p>上面便是 newtype 模式如何与 trait 结合使用的；还有一个不涉及 trait 的实用模式。现在让我们将话题的焦点转移到一些与 Rust 类型系统交互的高级方法上来吧。</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="ch19-02-advanced-lifetimes.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch19-04-advanced-types.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch19-02-advanced-lifetimes.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch19-04-advanced-types.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>